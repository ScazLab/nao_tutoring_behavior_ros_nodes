# nao_tutoring_behavior_ros_nodes

This repository contains code for the ROS nodes controlling the tutoring behavior study. 
It is set up to run in Docker so that it may be run on any operating system, though the ROS code could be pulled out of the Docker container if being run on a Linux machiene.

# Running in Docker

To run the docker container, run the command:
```
docker run -it -p 9090:9090 -v  /*path_to*/nao_tutoring_behavior_ros/catkin_ws:/root/catkin_ws nao_tutoring_behavior
```

-p 9090:9090 specifies that port 9090 on your local machiene is mapped to port 9090 in the container. This is important to note for running the tablet server later.

In a second terminal, run:
```
docker ps -l
```

This will show you a list of docker containers open. Find the name of the open container in the last column. 
Then run:
```
docker exec -it *name_of_container* bash
```

Open two more docker terminals. Before running the ros nodes, you must first run:
```
source ./devel/setup.bash
```

In your four docker terminals, run the following commands (one per terminal):
```
roscore
rosrun nao_tutoring_behaviors node_model_dummy.py 
rosrun nao_tutoring_behaviors node_tablet.py 
rosrun nao_tutoring_behaviors node_robot_controller.py [--robot]            (the --robot flag indicates that the node should connect to Nao)
```

The ROS nodes are now running. In the terminal running node_tablet.py, you should see that it is waiting for the tablet to connect.

# ROS Messages
The nodes communicate via the following message streams:

robot_speech_msg : the robot publishes here to indicate when it begins and finishes speaking. This allows the tablet to disable buttons during this time.

robot_lesson_msg : the robot publishes here when it speaks to give an example. This lets the tablet react to robot speech during examples and tutorials to show the right steps at the next time. The model node does not subscribe to this.

robot_inactivity_msg : the robot publishes here when it speaks during other activities, like during a tictactoe game. This is separate so that the model is not spammed with too many messages between tablet node and robot during an activity. The model node does not subscribe to this.

These three prior messages are all simple strings.

tablet_msg : the tablet node publishes here to inform the model and the robot of what the tablet is doing and what actions should be taken. It sends a TabletMsg which contains a msgType (string), questionNumOrPart (int), robotSpeech (string) and a string of otherInfo.
Examples of msgTypes are 'CA' indicating a correct answer, 'IA' indicating an incorrect answer, 'TICTATOE-[WIN/LOSS]' indicating the end of a tictactoe game, 'START' to indicate the start of the session, or 'SHOWING-QUESTION' to indicate that the tablet has just displayed a question. Both the robot controller and model subscribe to this.

tablet_lesson_msg : the tablet node publishes here during an example to instruct the robot what to say. This is separate so that the robot can respond with a the robot_lesson_msg to trigger the next step, and so as to avoid sending too many unneeded messages to the model. 

tablet_inactivity_msg: the tablet node publishes here during other activities, like tic tac toe. Only the robot subscribes.

model_decision_msg : the model publishes the next action that should be taken. This is in the form of a ControlMsg, which contains a nextStep (string), questionNum, questionLevel, a string of robotSpeech and string of otherInfo.

Currently the "otherInfo" in both TabletMsgs and ControlMsgs is unused so I will probably remove it in a next commit. 

# Most important files and locations:
There are a lot of directories generated by ROS, so here are the paths of the most relevant and important things:
message types are all in /catkin_ws/src/nao_tutoring_behaviors/msg

The three node files are in:

/catkin_ws/src/nao_tutoring_behaviors/scripts/node_robot_controller.py
/catkin_ws/src/nao_tutoring_behaviors/scripts/node_tablet.py
/catkin_ws/src/nao_tutoring_behaviors/scripts/node_model_dummy.py

Code to generate the steps of division examples (e.g. finding the values that should go in structure boxes) is in:
/catkin_ws/src/nao_tutoring_behaviors/scripts/example_generation.py

# Running Nao
These instructions are adopted from [this previous project's README](https://github.com/ScazLab/nao_tutoring#nao-tutoring) which was written by Arsalan Sufi. They have been edited for relevance to the current project.

## Installation Instructions: Python Scripts

The project's Python scripts are located in the `python_scripts/` directory.

After cloning the repository, within the folder python_scripts/, type 'mkdir data'.
This creates a data directory that nao_server.py will look for when running the code.

### Installing naoqi

To run Nao code, the only module that you should need to install is `naoqi` (the Python NAOqi SDK).
This module can't be installed using `pip`.
You'll need to download the module from the [Aldebaran website](https://www.aldebaran.com/en).
Aldebaran provides installation instructions [here](http://doc.aldebaran.com/1-14/dev/python/install_guide.html).

Below are a few notes that supplement the linked instructions:

* To access the zip archives mentioned in Step 2, you'll need to log in to the [Aldebaran website](https://www.aldebaran.com/en).
  Ask someone in the lab for the login credentials.

* Once you've logged in, navigate to *Resources > Software > Python NAOqi SDK*.
  Download a zip archive for **version 1.14.5** of the SDK.
  This is the version used by the project.

* Step 3 makes sure that Python can find the `naoqi` module.
  After you've downloaded and unzipped your zip archive, the following command should do the trick for both Linux and MacOS:
    ```
    export PYTHONPATH=${PYTHONPATH}:/path/to/sdk/
    ```
  where `/path/to/sdk/` is the path to your unzipped zip archive.
  You can add this line to your `.bash_profile` or `.bashrc` to avoid having to type it into every new terminal.

### Running nao_server.py

You should now be able to run the ROS nodes as described above. The IP address is found in the code by `socket.gethostname()`, and the port is hard coded to 9090.
To determine your IP address, so that you can connect a tablet app connection to the socket, you can use `ifconfig` in your terminal.

**A quick but important note about Python binaries.**
The Python binary that you use to run the script should be a system binary.
A brew-installed binary likely won't work.
When I use my brew-installed Python 2.7 to run the script on Yosemite, Python crashes.

To check which Python binary you're actually using, type `which python` into your terminal.
If the binary is located in `/usr/local/bin/`, it's probably brew-installed.
To get the terminal to use the system binary instead, run
```
/usr/bin/python ...
```
instead of
```
python  ...
```
